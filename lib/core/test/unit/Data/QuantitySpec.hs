{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Data.QuantitySpec
    ( spec
    ) where

import Prelude

import Data.Quantity
    ( MkPercentageError (..), Percentage, Quantity (..), mkPercentage )
import Data.Text.Class
    ( FromText (..), ToText (..) )
import Test.Hspec
    ( Spec, describe, it, shouldBe )
import Test.QuickCheck
    ( Arbitrary (..)
    , arbitraryBoundedEnum
    , checkCoverage
    , cover
    , expectFailure
    , property
    , (===)
    )

import qualified Data.Aeson as Aeson


spec :: Spec
spec = do
    describe "Quantity" $ do
        it "fail to parse from JSON if unit doesn't match" $ do
            let msg =
                    "Error in $: failed to parse quantified value. Expected \
                    \value in 'bytes' (e.g. { \"unit\": \"bytes\", \"quantity\"\
                    \: ... }) but got something else."
            Aeson.eitherDecode "{\"unit\":\"patate\",\"quantity\":14}"
                `shouldBe`
                (Left @String @(Quantity "bytes" Int) msg)
        it "fromText . toText === pure"
            $ property $ \(i :: Int) -> (fromText . toText) i === pure i

    describe "Percentage" $ do
        it "fail to percent from JSON when out of bounds" $ do
            let msg = "Error in $.quantity: PercentageOutOfBoundsError"
            Aeson.eitherDecode "{\"unit\":\"percent\",\"quantity\":-14}"
                `shouldBe` (Left @String @(Quantity "percent" Percentage) msg)

        it "can't make percentage out of bound" $ checkCoverage $ \case
            n | n > 10 -> cover 25 True "n > 100" $
                -- NOTE taking 10 * n to get bigger Int generated by QuickCheck
                mkPercentage @Int (10 * n) === Left PercentageOutOfBoundsError
            n | n < 0 -> cover 25 True "n < 0" $
                mkPercentage @Int n === Left PercentageOutOfBoundsError
            n ->
                mkPercentage @Int n === Right (toEnum n)

        it "throw a runtime exception when 'toEnum' is used on invalid values" $
            expectFailure $ property $ \n -> toEnum @Percentage n `seq` ()

        it "roundtrip (toEnum . fromEnum)" $ property $ \(n :: Percentage) ->
            (toEnum . fromEnum) n === n


{-------------------------------------------------------------------------------
                              Arbitrary Instances
-------------------------------------------------------------------------------}

instance Arbitrary Percentage where
    shrink p
        | p == minBound = []
        | otherwise = [minBound]
    arbitrary = arbitraryBoundedEnum
